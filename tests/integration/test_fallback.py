import unittest
import sys
import logging
from unittest.mock import MagicMock, patch
from langchain_core.messages import SystemMessage, AIMessage

# Define a dummy AgentState since the real one is a TypedDict which can be simulated with a dict
# But we need to make sure imports work. 
# Explicitly adding current directory to path just in case
import os
sys.path.append(os.getcwd())

from chat import chat_node

class TestLLMFallback(unittest.TestCase):
    def setUp(self):
        # Suppress logging during tests to keep output clean
        logging.getLogger("StratGov_Agent").setLevel(logging.CRITICAL)

    @patch('chat.get_model')
    def test_fallback_logic_primary_fails_secondary_succeeds(self, mock_get_model):
        """
        Test that chat_node switches to fallback model when primary raises an exception.
        """
        print("\nTesting LLM Fallback: Primary(Error) -> Secondary(Success)...")
        
        # 1. Setup State
        state = {
            "messages": [SystemMessage(content="Test Query")],
            "model": "groq", # Primary
            "temperature": 0.5,
            "max_tokens": 100,
            "logs": []
        }

        # 2. Setup Mocks
        
        # Mock for Primary Model (Simulate Failure)
        mock_llm_primary = MagicMock()
        # The chain in chat.py is: llm.bind_tools(tools).invoke(messages)
        # So we mock the .invoke() on the bound object
        mock_bound_primary = MagicMock()
        mock_bound_primary.invoke.side_effect = Exception("Simulated Primary API Failure (Rate Limit)")
        mock_llm_primary.bind_tools.return_value = mock_bound_primary

        # Mock for Fallback Model (Simulate Success)
        mock_llm_fallback = MagicMock()
        mock_bound_fallback = MagicMock()
        mock_response = AIMessage(content="Response generated by fallback logic.")
        mock_bound_fallback.invoke.return_value = mock_response
        mock_llm_fallback.bind_tools.return_value = mock_bound_fallback

        # Configure get_model to return primary first, then fallback
        # First call: get_model(model="groq") -> returns mock_llm_primary
        # Second call: get_model(model="mixtral") -> returns mock_llm_fallback
        mock_get_model.side_effect = [mock_llm_primary, mock_llm_fallback]

        # 3. Execute
        result = chat_node(state)

        # 4. Verify
        logs = result["logs"]
        messages = result["messages"]
        final_content = messages[0].content

        # Check Logs for failure warning
        failure_log = next((log for log in logs if "Primary model (groq) failed" in log.message), None)
        self.assertIsNotNone(failure_log, "Should log primary model failure")
        print(f"✅ Logged Failure: {failure_log.message}")

        # Check Logs for switch info
        switch_log = next((log for log in logs if "Switching to fallback model" in log.message), None)
        self.assertIsNotNone(switch_log, "Should log switching to fallback")
        print(f"✅ Logged Switch: {switch_log.message}")
        
        # Check Final Content has the signature
        self.assertIn("Response generated by fallback logic", final_content)
        self.assertIn("(Generated via fallback model", final_content)
        print(f"✅ Final Response includes fallback signature: '{final_content}'")

        # Verify get_model was called with expected arguments
        # Call 1: Primary
        mock_get_model.assert_any_call(model_name="groq", temperature=0.5, max_tokens=100)
        # Call 2: Fallback (should be mixtral for groq input)
        mock_get_model.assert_any_call(model_name="mixtral", temperature=0.5, max_tokens=100)

    @patch('chat.get_model')
    def test_fallback_critical_failure(self, mock_get_model):
        """
        Test that chat_node returns graceful error if BOTH models fail.
        """
        print("\nTesting LLM Fallback: Primary(Error) -> Secondary(Error)...")

        state = {
            "messages": [SystemMessage(content="Test Query")],
            "model": "llama", 
            "logs": []
        }

        # Both mocks fail
        mock_llm_fail = MagicMock()
        mock_bound_fail = MagicMock()
        mock_bound_fail.invoke.side_effect = Exception("API Down")
        mock_llm_fail.bind_tools.return_value = mock_bound_fail

        mock_get_model.side_effect = [mock_llm_fail, mock_llm_fail]

        result = chat_node(state)
        
        final_content = result["messages"][0].content
        self.assertIn("System Unavailable", final_content)
        print(f"✅ Graceful Exit verified: '{final_content}'")

if __name__ == '__main__':
    unittest.main()
